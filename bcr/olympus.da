import sys
config(channel is fifo, clock is lamport)
from enum import Enum
import nacl.encoding
import nacl.signing
from OrderProof import OrderProof
from OrderStatement import OrderStatement
from Crypto import Crypto
from State import State
from Validations import Validations
from ResultProof import ResultProof
from ResultStatement import ResultStatement
from Shuttle import Shuttle
from ReplicaHistory import ReplicaHistory
from  ReconfigurationRequestObject import ReconfigurationRequestObject
from configread import configread
import pickle
str_exp = ','
log_level = 20
cl = import_da('client')
rl = import_da('replica')


class Olympus(process):

	def setup(nReplicas: int, clients: cl.Client, olympusPrivate: nacl.signing.SigningKey, olympusPublic: nacl.signing.SigningKey, clientPublic: list, failures: dict, nonhead_timeout: int,config:configread):
		self.head = None
		self.tail = None
		self.replicas = []
		self.olympusPrivate = olympusPrivate
		self.olympusPublic = olympusPublic
		self.clientPublic = clientPublic
		self.replicaPublicKeysList = []
		self.replicaPrivateKeysList = []
		self.isConfigurationValid = False
		self.failure = failures
		self.configuration = -1
		self.crypto = Crypto()
		self.listOfWedgeStatements = []
		self.numberOfWedgedResponses = 0
		self.running_State = dict()
		self.lastCheckPointAccepted = None
		self.t = config.failure_num
	
		
	def createNewReplica():
		replicas = new(rl.Replica, num=nReplicas)
		replicas = list(replicas)
		configuration = configuration + 1
		self.head = replicas[0]
		self.tail = replicas[nReplicas - 1]
		self.replicaPublicKeysList=[]
		self.replicaPrivateKeysList=[]
		for i in range(nReplicas):
			(private, public) = crypto.getSignedKey()
			self.replicaPrivateKeysList.append(private)
			self.replicaPublicKeysList.append(public)
		output('replica private keys')
		output(' %s' % (replicaPrivateKeysList,))
		output('replica public keys')
		output(' %s' % (replicaPublicKeysList,))
		setup(replicas, (self, State.PENDING.value, olympusPublic, clientPublic,
                   replicaPublicKeysList, replicaPrivateKeysList, nonhead_timeout))
		start(replicas)
		c = logical_clock()
		for i in range(nReplicas):
			failcase = []
			if (configuration, i) in failure.keys():
				failcase = failure[(configuration, i)]
			send(('inithist', running_State, replicas, head, tail,
                            i, c, configuration, failcase), to=replicas[i])
			output("Message inithist sent to replica %i" %
			       (i,), sep=str_exp, level=log_level)
		

	def run():
		output('Starting Olympus', sep=str_exp, level=log_level)
		createNewReplica()
		c = logical_clock()
		

		await(each(client in clients, has=some(received(('done', _client, _)))))
		output('olympus received done from all clients')
		output('olympus sending  done to all replicas')
		send(('done',), to=replicas)
		await(each(replica in replicas, has=some(received(('done', _replica)))))
		output('olympus received  done from all replicas')
		send(('done',), to=parent())

		output('Olympus process is getting closed', sep=str_exp, level=log_level)

	def receive(msg=('getconfiguration', clientNumber), from_=p):
		send(('getconfiguration_response', self.isConfigurationValid), to=p)

	def receive(msg=('configuration_request', clientNumber), from_=p):
		output('Olympus received configuration_request from client %i' %
		       (clientNumber,), sep=str_exp, level=log_level)
		await(each(replica in replicas, has=some(
			received(('inithist_response', _replica)))))
		self.isConfigurationValid = True
		output('Olympus sending configuration response to client %i' %
		       (clientNumber,), sep=str_exp, level=log_level)
		send(('configuration_response', replicas, head, tail, logical_clock(),self.replicaPublicKeysList), to=p)
	
	def getPublicKey(index,type):
		if type == 'client' :
			return clientPublic[index]

		else:
			return replicaPublicKeysList[index]


	def receive(msg=('reconfiguration_request', signedReq,index,type), from_=p):
		msg = crypto.isSignatureVerified(getPublicKey(index,type),signedReq)
		if msg != None:
			output('Olympus received reconfiguration_request:%s ' %(msg,), sep = str_exp, level = log_level)
			self.isConfigurationValid = False
			req = 'wedge'
			signedReq = crypto.sign(olympusPrivate, req)
			listOfWedgeStatements = []
			numberOfWedgedResponses = 0
			send(('wedge', signedReq), to=replicas)
			output('Olympus sent wedge requests to all replicas', sep = str_exp, level = log_level)
			
			if await(numberOfWedgedResponses >= t + 1):
				
				listOfWedgeStatements.sort(key=lambda tup:-1*tup[0])
				start =0
				(start,quoram) = findConsistentHistories(listOfWedgeStatements,start)
				
					
		else:
			output('Reconfiguration Request not signed by correct process', sep = str_exp, level = log_level)
			
			
	def findConsistentHistories(sortedByLongestHistory,start):
		
		
		while(start < len(sortedByLongestHistory)):
			
			lh = sortedByLongestHistory[start]
			remaining = sortedByLongestHistory[start+1:]
			numberOfConsistentHistoriesFound = 0
			res = []
			res.append(lh)
			i =start +1
			while (numberOfConsistentHistoriesFound < t+1 and i < len(remaining)) :
				curList = remaining[i]
				
				if curList[2].slotOperationHist.items() <= lh.slotOperationHist.items():
					numberOfConsistentHistoriesFound+=1
					res.append(curList)
					
				i = i+1
				
			if numberOfConsistentHistoriesFound == t+1:
				return (start,res)
			else:
				start+=1
				
		return (start,None)
	
	def receive(msg=('wedged', wedgeSt,index,type), from_=p):
	
		msg = crypto.isSignatureVerified(getPublicKey(index,type),wedgeSt)
		if msg != None:
	
			output('Olympus received wedgeStatement:%s from replica:%s'%(msg,index,), sep = str_exp, level = log_level)
			listOfWedgeStatements.append((len(msg.slotOperationHist),p,msg))
			numberOfWedgedResponses = numberOfWedgedResponses +1
		else:
			output('WedgeStatement not signed by correct replica', sep = str_exp, level = log_level)